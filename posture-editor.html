<!DOCTYPE html>

<html>

	<head>
		<script src="three.min.js"></script>
		<script src="OrbitControls.js"></script>
		<script src="mannequin.js"></script>
		
		<style>
		/* Toggle input based on https://codepen.io/avstorm/pen/jOEpBLW */
		input[type=checkbox] {
			-webkit-appearance: none;
			-moz-appearance: none;
			appearance: none;
			-webkit-tap-highlight-color: transparent;
		}

		input[type=checkbox]:focus {
			outline: 0;
		}

		label {
			cursor: pointer;
			display: block;
			margin-bottom: 10px;
		}
		
		label span {
			font-size: 12px;
			#font-weight: bold;
			font-family: Sans-serif;
			display: inline-block;
			margin-left: 5px;
			#border: solid 1px red;
			text-transform: uppercase;
			letter-spacing: 1px;
			vertical-align: middle;
		}
		
		.toggle {
			height: 24px;
			width: 56px;
			border-radius: 12px;
			display: inline-block;
			position: relative;
			margin: 0;
			padding: 0;
			border: 1px solid gray;
			background: rgba(0,0,0,3%);
			vertical-align: middle;
		}
		.toggle:after {
			content: "";
			position: absolute;
			top: 2px;
			left: 2px;
			width: 16px;
			height: 16px;
			border-radius: 50%;
			background: rgba(0,0,0,10%);
			border: solid 1px gray;
		}
		.toggle:checked {
			#border-color: green;
		}
		.toggle:checked+span {
			font-weight: bold;
		}
		.toggle:checked:after {
			border-color: darkgreen;
			background: seagreen;
			transform: translatex(32px);
		}
	  </style>
	  
	</head>
	
	<body>
		<label><input id="ik" type="checkbox" class="toggle"><span>&nbsp;Inverse &nbsp;kinematics</span></label><br>
		<label><input id="m2" type="checkbox" class="toggle"><span>&nbsp;Secondary &nbsp;motion</span></label>
		<label><input id="m3" type="checkbox" class="toggle"><span>&nbsp;Tertiary &nbsp;motion</span></label>
	
		<script>
			// create a scene with a better shadow
			createScene();
			var light = scene.children[0];
				light.shadow.mapSize.width = 4*1024;
				light.shadow.mapSize.height = 4*1024;	

			var controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.update();

			var model = new Female();
				model.turn( -90 );
				model.l_leg.straddle( -4 );
				model.r_leg.straddle( -4 );
				model.l_ankle.tilt( -4 );
				model.r_ankle.tilt( -4 );
				model.position.y = 2.2;

			model.l_tips = model.l_fingers.tips;
			model.r_tips = model.r_fingers.tips;
			
			const AXIS = {	X: new THREE.Vector3(1,0,0), 			
							Y: new THREE.Vector3(0,1,0), 			
							Z: new THREE.Vector3(0,0,1)
						};

			var dragPoint = new THREE.Mesh(
				new THREE.SphereBufferGeometry( 0.001 ),
				new THREE.MeshBasicMaterial({color:0})
			);
			
			var screenPoint = new THREE.Vector3();
			
			var names = ['pelvis', 'torso', 'neck', 'head', 'l_leg', 'l_knee', 'l_ankle', 'l_arm', 'l_elbow', 'l_wrist', 'l_fingers', 'l_tips', 'r_leg', 'r_knee', 'r_ankle', 'r_arm', 'r_elbow', 'r_wrist', 'r_fingers', 'r_tips'];
			for( var name of names )
			{
				model[name].x = 0;
				for( var part of model[name].children[0].children[0].children )
					part.name = name;
				for( var part of model[name].children[0].children[0].children[0].children )
					part.name = name;
				if( model[name].children[0].children[0].children[1] )
					for( var part of model[name].children[0].children[0].children[1].children )
						part.name = name;
			}
			model.l_ankle.x = -2;
			model.r_ankle.x = -2;
			
			var elemIK = document.getElementById( 'ik' ),
				elemM2 = document.getElementById( 'm2' ),
				elemM3 = document.getElementById( 'm3' );
			
			var mouse = new THREE.Vector2(),
				mouseButton = undefined,
				raycaster = new THREE.Raycaster();  
			
			document.addEventListener( 'mousedown', onMouseDown );
			document.addEventListener( 'mouseup', onMouseUp );
			document.addEventListener( 'mousemove', onMouseMove );
			
			elemM2.addEventListener( 'change', function(elem){if(elem.target.checked) elemM3.checked=false;} );
			elemM3.addEventListener( 'change', function(elem){if(elem.target.checked) elemM2.checked=false;} );
			 
			var obj = undefined;
			
			
			function onMouseUp( event )
			{
				controls.enabled = true;
				mouseButton = undefined;
				deselect( );
			}

			function select( object )
			{
				if( obj ) deselect( );
				
				obj = object;
				obj.select( true );
			}
			
			function deselect( )
			{
				if( !obj ) return;
				
				obj.select( false );
				obj = undefined;
			}
			
			function onMouseDown( event )
			{
				event.preventDefault();
				
				mouseButton = event.buttons;
				
				mouse.x = event.clientX/window.innerWidth * 2 - 1;
				mouse.y = -event.clientY/window.innerHeight * 2 + 1;
				
				raycaster.setFromCamera( mouse, camera );
				
				var intersects = raycaster.intersectObject( model, true );
				
				if( intersects.length )
				{
					controls.enabled = false;
					select( model[intersects[0].object.name] );
					
					dragPoint.position.copy( obj.worldToLocal(intersects[0].point) );
					obj.add( dragPoint );
				}
			}

			function relativeTurn( joint, axis, angle )
			{
				joint.rotateOnAxis( axis, rad(angle) );
				joint.updateMatrix();
			}
			
			function kinematic2D( joint, axis, angle, ignoreIfPositive )
			{
				// returns >0 if this turn gets closer
				
				screenPoint.copy( dragPoint.position );
				screenPoint = obj.localToWorld( screenPoint ).project( camera );
				var distOriginal = mouse.distanceTo( screenPoint );
				
				relativeTurn( joint, axis, angle );
				joint.updateMatrixWorld( true );
				
				screenPoint.copy( dragPoint.position );
				screenPoint = obj.localToWorld( screenPoint ).project( camera );
				var distProposed = mouse.distanceTo( screenPoint );

				var dist = distOriginal-distProposed;
				
				if( ignoreIfPositive && dist>0 ) return dist;
				
				relativeTurn( joint, axis, -angle );
				joint.updateMatrixWorld( true );
				
				return dist;
			}
			
			function inverseKinematics( joint, axis )
			{
				// try going in postive or negative direction
				var kPos = kinematic2D(joint,axis,0.01),
					kNeg = kinematic2D(joint,axis,-0.01);

				// if both make worse results, then exit
				if( kPos>0 || kNeg>0 )
				{
					var step = Math.sign( kPos-kNeg )/2;
					while( Math.abs(step)>0.001 )
					{
						while( kinematic2D(joint,axis,step,true)>0 );
						step /= 2;
					}
				}
			}
			
			function animate()
			{
				// no selected object
				if( !obj ) return;

				if( mouseButton & 0x01 && !elemM2.checked && !elemM3.checked )
				{
					var joint = obj;
					while( !(joint instanceof Pelvis) )
					{
						inverseKinematics( joint, AXIS.Z );
						joint = joint.parent.parent;
						if( (joint instanceof Torso) || !elemIK.checked ) break;
					}
				}
				
				if( mouseButton & 0x02 || elemM2.checked )
				{
					inverseKinematics( obj, AXIS.X );
				}
				
				if( mouseButton & 0x04 || elemM3.checked )
				{
					inverseKinematics( obj, AXIS.Y );
				}
				
			}
			
			function onMouseMove( event )
			{
				if( !obj ) return;
				
				event.preventDefault();
				
				mouse.x = event.clientX/window.innerWidth * 2 - 1;
				mouse.y = -event.clientY/window.innerHeight * 2 + 1;
	
				mouseButton = event.buttons;
			}
			
		</script>
	</body>
	
</html>