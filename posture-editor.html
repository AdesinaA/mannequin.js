<!DOCTYPE html>

<html>

	<head>
		<script src="three.min.js"></script>
		<script src="OrbitControls.js"></script>
		<script src="mannequin.js"></script>
		
		<style>
		/* Toggle input based on https://codepen.io/avstorm/pen/jOEpBLW */
		input[type=checkbox] {
			-webkit-appearance: none;
			-moz-appearance: none;
			appearance: none;
			-webkit-tap-highlight-color: transparent;
			outline: 0;
		}

/*https://css-tricks.com/styling-cross-browser-compatible-range-inputs-css/*/
input[type=range] {
  width: 15em;
  margin: 7.9px 0;
  background-color: transparent;
  -webkit-appearance: none;
}
input[type=range]:focus {
  outline: none;
}
input[type=range]::-webkit-slider-runnable-track {
  background: rgba(48, 113, 169, 0);
  border: 0.2px solid #010101;
  border-radius: 24.9px;
  width: 100%;
  height: 9.2px;
  cursor: pointer;
}
input[type=range]::-webkit-slider-thumb {
  margin-top: -8.1px;
  width: 25px;
  height: 25px;
  background: #ffffff;
  border: 1px solid #000000;
  border-radius: 25px;
  cursor: pointer;
  -webkit-appearance: none;
}
input[type=range]:focus::-webkit-slider-runnable-track {
  background: #438bc9;
}
input[type=range]::-moz-range-track {
  background: rgba(48, 113, 169, 0);
  border: 0.2px solid #010101;
  border-radius: 24.9px;
  width: 100%;
  height: 9.2px;
  cursor: pointer;
}
input[type=range]::-moz-range-thumb {
  width: 25px;
  height: 25px;
  background: #ffffff;
  border: 1px solid #000000;
  border-radius: 25px;
  cursor: pointer;
}
input[type=range]::-ms-track {
  background: transparent;
  border-color: transparent;
  border-width: 7.9px 0;
  color: transparent;
  width: 100%;
  height: 9.2px;
  cursor: pointer;
}
input[type=range]::-ms-fill-lower {
  background: #255681;
  border: 0.2px solid #010101;
  border-radius: 49.8px;
}
input[type=range]::-ms-fill-upper {
  background: rgba(48, 113, 169, 0);
  border: 0.2px solid #010101;
  border-radius: 49.8px;
}
input[type=range]::-ms-thumb {
  width: 25px;
  height: 25px;
  background: #ffffff;
  border: 1px solid #000000;
  border-radius: 25px;
  cursor: pointer;
  margin-top: 0px;
  /*Needed to keep the Edge thumb centred*/
}
input[type=range]:focus::-ms-fill-lower {
  background: rgba(48, 113, 169, 0);
}
input[type=range]:focus::-ms-fill-upper {
  background: #438bc9;
}
/*TODO: Use one of the selectors from https://stackoverflow.com/a/20541859/7077589 and figure out
how to remove the virtical space around the range input in IE*/
@supports (-ms-ime-align:auto) {
  /* Pre-Chromium Edge only styles, selector taken from hhttps://stackoverflow.com/a/32202953/7077589 */
  input[type=range] {
    margin: 0;
    /*Edge starts the margin from the thumb, not the track as other browsers do*/
  }
}/***********************/
		span.short { display:inline-block; width:2em; text-align: right;}

		#panel {
			padding: 1em 0 0 1em;
			width:15em;
			position:fixed;
			top:0;
			left:0;
			z-index: 10;
		}
		
		label {
			cursor: pointer;
			display: inline-block;
			margin-bottom: 10px;
			z-index: 10;
			
		}
		
		label span {
			font-size: 10px;
			font-family: Sans-serif;
			display: inline-block;
			margin-left: 5px;
			text-transform: uppercase;
			letter-spacing: 1px;
			vertical-align: middle;
			color: gray;
		}
		
		.toggle {
			height: 24px;
			width: 56px;
			border-radius: 12px;
			display: inline-block;
			position: relative;
			margin: 0;
			padding: 0;
			border: 1px solid gray;
			background: rgba(0,0,0,3%);
			vertical-align: middle;
		}
		.toggle:after {
			content: "";
			position: absolute;
			top: 2px;
			left: 2px;
			width: 16px;
			height: 16px;
			border-radius: 50%;
			background: rgba(0,0,0,10%);
			border: solid 1px gray;
		}
		.toggle:checked {
			#border-color: green;
		}
		.toggle:checked+span {
			color: black;
			font-weight: bold;
		}
		.toggle:checked:after {
			border-color: darkgreen;
			background: seagreen;
			transform: translatex(32px);
		}
	  </style>
	  
	</head>
	
	<body>
		<div id="panel">
			<label><input id="ik" type="checkbox" class="toggle" checked><span>&nbsp;Inverse &nbsp;kinematics</span></label><br>
			<label><input id="br" type="checkbox" class="toggle" checked><span>&nbsp;Biological &nbsp;restriction</span></label><br>
			<br>
			<label><span id="name"></span></label><br>
			<label id="labelz" style="visibility:hidden;"><input id="m1" type="checkbox" class="toggle" checked><span id="namez"></span></label><br>
			<label id="labelx" style="visibility:hidden;"><input id="m2" type="checkbox" class="toggle" ><span id="namex"></span></label><br>
			<label id="labely" style="visibility:hidden;"><input id="m3" type="checkbox" class="toggle"><span id="namey"></span></label><br>
			<div style="display:none;">
			<label><span id="vx" class="short"></span></span><input type="range" id="rx" value="0" min="-180" max="180" step="5"><br>
			<span id="vy" class="short"></span><input type="range" id="ry" value="0" min="-180" max="180" step="5"><br>
			<span id="vz" class="short"></span><input type="range" id="rz" value="0" min="-180" max="180" step="5"><br></div>
		</div>
		
		<script>
			const EPS = 0.00001;
			
			// create a scene with a better shadow
			createScene();
			var light = scene.children[0];
				light.shadow.mapSize.width = 4*1024;
				light.shadow.mapSize.height = 4*1024;	

			var controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.update();

			var model = new Male();

			model.l_tips = model.l_fingers.tips;
			model.r_tips = model.r_fingers.tips;


			var dragPoint = new THREE.Mesh(
				new THREE.SphereBufferGeometry( 0.001 ),
				new THREE.MeshBasicMaterial({color:0})
			);
			
			var screenPoint = new THREE.Vector3();
			
			var names = [
				['pelvis','tilt','turn','bend','body'],
				['torso','tilt','turn','bend','torso'],
				['neck','tilt','turn','nod','neck'],
				['head','tilt','turn','nod','head'],
				['l_leg','straddle','turn','raise','left leg'],
				['l_knee','','','bend','left knee'],
				['l_ankle','tilt','turn','bend','left ankle'],
				['l_arm','straddle','turn','raise','left arm'],
				['l_elbow','','','bend','left elbow'],
				['l_wrist','tilt','turn','bend','left wrist'],
				['l_fingers','','','bend','left fingers'],
				['l_tips','','','bend','left finger tips'],
				['r_leg','straddle','turn','raise','right leg'],
				['r_knee','','','bend','right knee'],
				['r_ankle','tilt','turn','bend','right ankle'],
				['r_arm','straddle','turn','raise','right arm'],
				['r_elbow','','','bend','right elbow'],
				['r_wrist','tilt','turn','bend','right wrist'],
				['r_fingers','','','bend','right fingers'],
				['r_tips','','','bend','right finger tips']
			];
			var properties
			for( var nameData of names )
			{
				var name = nameData[0];
				for( var part of model[name].children[0].children )
					part.name = name;
				for( var part of model[name].children[0].children[0].children )
					part.name = name;
				if( model[name].children[0].children[1] )
					for( var part of model[name].children[0].children[1].children )
						part.name = name;
				model[name].name = {x:nameData[1], y:nameData[2], z:nameData[3]};
				model[name].fullName = nameData[4];
			}
			
			var elemIK = document.getElementById( 'ik' ),
				elemBR = document.getElementById( 'br' ),
				elemM1 = document.getElementById( 'm1' ),
				elemM2 = document.getElementById( 'm2' ),
				elemM3 = document.getElementById( 'm3' );
			
			var mouse = new THREE.Vector2(),
				mouseButton = undefined,
				raycaster = new THREE.Raycaster();  
			
			document.addEventListener( 'mousedown', onMouseDown );
			document.addEventListener( 'mouseup', onMouseUp );
			document.addEventListener( 'mousemove', onMouseMove );
			
			document.getElementById( 'rx' ).addEventListener( 'input', onChangedSlider );
			document.getElementById( 'ry' ).addEventListener( 'input', onChangedSlider );
			document.getElementById( 'rz' ).addEventListener( 'input', onChangedSlider );
			
			elemM1.addEventListener( 'change', function(elem){if(elem.target.checked) elemM2.checked=elemM3.checked=false;} );
			elemM2.addEventListener( 'change', function(elem){if(elem.target.checked) elemM1.checked=elemM3.checked=false;} );
			elemM3.addEventListener( 'change', function(elem){if(elem.target.checked) elemM1.checked=elemM2.checked=false;} );
			 
			var obj = undefined,
				lastObj = undefined;
			
			
			function onMouseUp( event )
			{
				controls.enabled = true;
				mouseButton = undefined;
				deselect( );
			}

			function select( object )
			{
				if( obj ) deselect( );

				lastObj = obj = object;
				obj.select( true );
			}
			
			function deselect( )
			{
				if( !obj ) return;
				
				obj.select( false );
				obj = undefined;
			}
			
			function onMouseDown( event )
			{
//				event.preventDefault();
				
				mouseButton = event.buttons;
				
				mouse.x = event.clientX/window.innerWidth * 2 - 1;
				mouse.y = -event.clientY/window.innerHeight * 2 + 1;
				
				raycaster.setFromCamera( mouse, camera );
				
				var intersects = raycaster.intersectObject( model, true );

				if( intersects.length )
				{
					controls.enabled = false;
					
					var name = intersects[0].object.name;
					select( model[name] );

					document.getElementById('name').innerHTML = model[name].fullName;
					document.getElementById('namex').innerHTML = model[name].name.x||'axis x';
					document.getElementById('namey').innerHTML = model[name].name.y||'axis y';
					document.getElementById('namez').innerHTML = model[name].name.z||'axis z';
			
					document.getElementById('labelx').style.visibility = (!elemBR.checked || model[name].name.x)?'visible':'hidden';
					document.getElementById('labely').style.visibility = (!elemBR.checked || model[name].name.y)?'visible':'hidden';
					document.getElementById('labelz').style.visibility = (!elemBR.checked || model[name].name.z)?'visible':'hidden';

					dragPoint.position.copy( obj.worldToLocal(intersects[0].point) );
					obj.add( dragPoint );
				}
			}

			function relativeTurn( joint, rotationalAngle, angle )
			{
				if( elemBR.checked )
				{
					var val = joint[rotationalAngle],
						min = joint.minRot[rotationalAngle],
						max = joint.maxRot[rotationalAngle];
						
					if( val<min-EPS && angle<0 ) return;
					if( val>max+EPS && angle>0 ) return;
					if( min == max ) return;
				}
				joint[rotationalAngle] += angle;
				joint.updateMatrix();
				
				document.getElementById("rx").value = joint.x;
				document.getElementById("ry").value = joint.y;
				document.getElementById("rz").value = joint.z;
				document.getElementById("vx").innerHTML = joint.x.toFixed(0);
				document.getElementById("vy").innerHTML = joint.y.toFixed(0);
				document.getElementById("vz").innerHTML = joint.z.toFixed(0);
/*			
//console.log('from\t',joint.rotation.x.toFixed(3),joint.rotation.y.toFixed(3),joint.rotation.z.toFixed(3));
				var oldRotation = joint[rotationalAngle];
				joint[rotationalAngle] += angle;
//console.log('\tvia\t',joint.rotation.x.toFixed(3),joint.rotation.y.toFixed(3),joint.rotation.z.toFixed(3));
				if( elemBR.checked )
				{
					var val = joint[rotationalAngle],
						min = joint.minRot[rotationalAngle],
						max = joint.maxRot[rotationalAngle],
						impossible;
							
					// normalize angle between 0 and 359
					val = ((val%360)+360)%360;
					if( min-EPS <= max+EPS )
					{
						impossible = val<min-EPS || max+EPS<val;
					}
					else
					{
						impossible = max-EPS<val && val<min+EPS;
					}

					if( impossible )
					{
						joint[rotationalAngle] = oldRotation;
					}
				}

//console.log(joint.rotation.x.toFixed(2),joint.rotation.y.toFixed(2),joint.rotation.z.toFixed(2));
				joint.updateMatrix();
*/
			}
			
			function kinematic2D( joint, rotationalAngle, angle, ignoreIfPositive )
			{
				// returns >0 if this turn gets closer
				
				screenPoint.copy( dragPoint.position );
				screenPoint = obj.localToWorld( screenPoint ).project( camera );
				var distOriginal = mouse.distanceTo( screenPoint );
				
				relativeTurn( joint, rotationalAngle, angle );
				joint.updateMatrixWorld( true );
				
				screenPoint.copy( dragPoint.position );
				screenPoint = obj.localToWorld( screenPoint ).project( camera );
				var distProposed = mouse.distanceTo( screenPoint );

				var dist = distOriginal-distProposed;
				
				if( ignoreIfPositive && dist>0 ) return dist;
				
				relativeTurn( joint, rotationalAngle, -angle );
				joint.updateMatrixWorld( true );
				
				return dist;
			}
			
			function inverseKinematics( joint, rotationalAngle )
			{
				// try going in postive or negative direction
				var kPos = kinematic2D(joint,rotationalAngle,0.1),
					kNeg = kinematic2D(joint,rotationalAngle,-0.1);

				// if both make worse results, then exit
				if( kPos>0 || kNeg>0 )
				{
					var step = Math.sign( kPos-kNeg )/2;
					while( Math.abs(step)>0.01 )
					{
						while( kinematic2D(joint,rotationalAngle,step,true)>0 );
						step /= 2;
					}
				}
			}
			
			function animate( time )
			{
				// no selected object
				if( !obj ) return;

				if( (mouseButton & 0x01) && !elemM2.checked && !elemM3.checked )
				{
					var joint = obj;
					do
					{
						inverseKinematics( joint, 'z' );
						joint = joint.parent;
					}
					while( !(joint instanceof Mannequin) && !(joint instanceof Pelvis) && !(joint instanceof Torso) && elemIK.checked );
				}
				else
				if( mouseButton & 0x02 || elemM2.checked )
				{
					inverseKinematics( obj, 'x' );
				}
				else
				if( mouseButton & 0x04 || elemM3.checked )
				{
					inverseKinematics( obj, 'y' );
				}

			}
			
			function onMouseMove( event )
			{
				if( !obj ) return;
				
				event.preventDefault();
				
				mouse.x = event.clientX/window.innerWidth * 2 - 1;
				mouse.y = -event.clientY/window.innerHeight * 2 + 1;
	
				mouseButton = event.buttons;
			}
		
			function onChangedSlider()
			{
				if( !lastObj ) return;
				
				lastObj.x = Number(document.getElementById("rx").value);
				lastObj.y = Number(document.getElementById("ry").value);
				lastObj.z = Number(document.getElementById("rz").value);
				document.getElementById("vx").innerHTML = lastObj.x;
				document.getElementById("vy").innerHTML = lastObj.y;
				document.getElementById("vz").innerHTML = lastObj.z;
			}
			
		</script>
	</body>
	
</html>