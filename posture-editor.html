<!DOCTYPE html>

<html>

	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="posture-editor.css">

		<script src="three.min.js"></script>
		<script src="OrbitControls.js"></script>
		<script src="mannequin.js"></script>
	</head>
	
	<body>
		<div id="panel">
			<label><input id="ik" type="checkbox" class="toggle"><span>Inverse<br>kinematics</span></label><br>
			<label><input id="br" type="checkbox" class="toggle"><span>Biological<br>restriction</span></label><br><br>
			<label id="labelz"><input id="m1" type="checkbox" class="toggle"><span id="namez">N/A</span></label><br>
			<label id="labelx"><input id="m2" type="checkbox" class="toggle" ><span id="namex">N/A</span></label><br>
			<label id="labely"><input id="m3" type="checkbox" class="toggle"><span id="namey">N/A</span></label><br>
			<label id="labelm" style="display:none;"><input id="m4" type="checkbox" class="toggle"><span>Move</span></label>
		</div>
		
		<script>
			const EPS = 0.00001;
			var mouseInterface = false;
			var touchInterface = false;
			
			// create a scene with a better shadow
			createScene();
			var light = scene.children[0];
				light.shadow.mapSize.width = 4*1024;
				light.shadow.mapSize.height = 4*1024;	

			var controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.update();

			var model = new Male();
			
			model.l_tips = model.l_fingers.tips;
			model.r_tips = model.r_fingers.tips;

			var texture = generateTexture();
			
			var circle = new THREE.Mesh(
				new THREE.CircleBufferGeometry(10,32,2*Math.PI,Math.PI),
				new THREE.MeshPhongMaterial({
					side: THREE.DoubleSide,
					color: 'navy',
					transparent: true, 
					alphaMap: texture
				})
			);
			
			circle.add( new THREE.Mesh(
				new THREE.CylinderBufferGeometry(10,10,1/2,32,1,true,2.5*Math.PI,Math.PI).rotateX(Math.PI/2),
				new THREE.MeshBasicMaterial({
					side: THREE.DoubleSide,
					color: 'black'
				})
			));
			
			circle.add( new THREE.Mesh(
				new THREE.ConeBufferGeometry(0.5,-2,6).translate(9.75,-1.5,0),
				new THREE.MeshBasicMaterial({color: 'black'})
			));
			
			circle.add( new THREE.Mesh(
				new THREE.ConeBufferGeometry(0.5,-2,6).translate(-9.75,-1.5,0),
				new THREE.MeshBasicMaterial({color: 'black'})
			));
			
			var dragPoint = new THREE.Mesh(
				new THREE.SphereBufferGeometry( 0.001 ),
				new THREE.MeshBasicMaterial({color:0})
			);
			
			var screenPoint = new THREE.Vector3();
			
			var names = [
				['pelvis','tilt','turn','bend'],
				['torso','tilt','turn','bend'],
				['neck','tilt','turn','nod'],
				['head','tilt','turn','nod'],
				['l_leg','straddle','turn','raise'],
				['l_knee','','','bend'],
				['l_ankle','tilt','turn','bend'],
				['l_arm','straddle','turn','raise'],
				['l_elbow','','','bend'],
				['l_wrist','tilt','turn','bend'],
				['l_fingers','','','bend'],
				['l_tips','','','bend'],
				['r_leg','straddle','turn','raise'],
				['r_knee','','','bend'],
				['r_ankle','tilt','turn','bend'],
				['r_arm','straddle','turn','raise'],
				['r_elbow','','','bend'],
				['r_wrist','tilt','turn','bend'],
				['r_fingers','','','bend'],
				['r_tips','','','bend']
			];
			
			for( var nameData of names )
			{
				var name = nameData[0];
				for( var part of model[name].children[0].children )
					part.name = name;
				for( var part of model[name].children[0].children[0].children )
					part.name = name;
				if( model[name].children[0].children[1] )
					for( var part of model[name].children[0].children[1].children )
						part.name = name;
				model[name].nameUI = {x:nameData[1], y:nameData[2], z:nameData[3]};
			}
			
			var elemIK = document.getElementById( 'ik' ),
				elemBR = document.getElementById( 'br' ),
				elemM1 = document.getElementById( 'm1' ),
				elemM2 = document.getElementById( 'm2' ),
				elemM3 = document.getElementById( 'm3' ),
				elemM4 = document.getElementById( 'm4' );
			
			var mouse = new THREE.Vector2(),
				mouseButton = undefined,
				raycaster = new THREE.Raycaster();  
			
			document.addEventListener( 'mousedown', onMouseDown );
			document.addEventListener( 'mouseup', onMouseUp );
			document.addEventListener( 'mousemove', onMouseMove );

			document.addEventListener( 'touchstart', onMouseDown );
			document.addEventListener( 'touchend', onMouseUp );
			document.addEventListener( 'touchcancel', onMouseUp );
			document.addEventListener( 'touchmove', onMouseMove );
			
			elemM1.addEventListener( 'change', function(elem){if(elem.target.checked) elemM2.checked=elemM3.checked=elemM4.checked=false; updateValues(elemM1);} );
			elemM2.addEventListener( 'change', function(elem){if(elem.target.checked) elemM1.checked=elemM3.checked=elemM4.checked=false; updateValues(elemM2);} );
			elemM3.addEventListener( 'change', function(elem){if(elem.target.checked) elemM1.checked=elemM2.checked=elemM4.checked=false; updateValues(elemM3);} );
			elemM4.addEventListener( 'change', function(elem){if(elem.target.checked) elemM1.checked=elemM2.checked=elemM3.checked=false; updateValues(elemM4);} );

			controls.addEventListener( 'start', function(){renderer.setAnimationLoop(drawFrame);} );
			controls.addEventListener( 'end', function(){renderer.setAnimationLoop(null);renderer.render(scene,camera);} );

			function updateValues( elem )
			{
				if( elem && touchInterface ) elem.checked = true;
				
				if( !obj ) return;

				if( elemM1.checked ) {obj.rotation.reorder('XYZ');}
				if( elemM2.checked ) {obj.rotation.reorder('YZX');}
				if( elemM3.checked ) {obj.rotation.reorder('ZXY');}
			}
			
			var obj = undefined,
				lastObj = undefined;
			
			function generateTexture( size=512 )
			{
				var canvas = document.createElement( 'canvas' );
					canvas.width = size;
					canvas.height = size;
				var r = size/2;
				
				var ctx = canvas.getContext( '2d' );
					ctx.fillStyle = 'black';
					ctx.fillRect( 0, 0, size, size );	

				var grd = ctx.createRadialGradient(size/2, size/2, r/2, size/2, size/2, r);
					grd.addColorStop(0, "black");
					grd.addColorStop(0.8, "gray");
					grd.addColorStop(1, "white");

					// Fill with gradient
					ctx.fillStyle = grd;
					ctx.fillRect( 1, 1, size-2, size-2 );	

				var start = Math.PI,
					end = 2*Math.PI;
					
				ctx.strokeStyle = 'white';
				ctx.lineWidth = 5;
				ctx.beginPath();
					ctx.moveTo( size/2, size/2 );
					ctx.lineTo( size/2, size/2-r );
				ctx.stroke();
				ctx.lineWidth = 10;
				for( var rr=r; rr>0; rr-=50 )
				{
					ctx.beginPath();
						ctx.arc( size/2, size/2, rr, start, end );
					ctx.stroke();
					ctx.lineWidth = 1;
				}
				for( var i=0; i<=6; i++ )
				{
				ctx.beginPath();
					ctx.moveTo( size/2, size/2 );
					var a = start + i/6*(end-start);
					ctx.lineTo( size/2+r*Math.cos(a), size/2+r*Math.sin(a) );
				ctx.stroke();
				}
				
				var texture = new THREE.CanvasTexture(canvas, THREE.UVMapping );
					texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
					texture.repeat.set( 1, 1 );
					
				return texture;
			}
			
			function onMouseUp( event )
			{
				controls.enabled = true;
				mouseButton = undefined;
				deselect( );
				renderer.setAnimationLoop(null);
				renderer.render( scene, camera );
			}

			function select( object )
			{
				deselect( );

				lastObj = obj = object;
				
				if( !obj ) return;
				
				obj.select( true );
				
				if( obj instanceof Pelvis )
				{
					document.getElementById('labelm').style.display = 'block';
				}
				else
				{
					document.getElementById('labelm').style.display = 'none';
					elemM4.checked = false;
				}
			}
			
			function deselect( )
			{
				circle.parent?.remove( circle );
				
				if( !obj ) return;
				
				obj.select( false );
				obj = undefined;
			}
			
			function onMouseDown( event )
			{
				userInput( event );
				
				circle.parent?.remove( circle );
				dragPoint.parent?.remove( dragPoint );
				
				raycaster.setFromCamera( mouse, camera );
				
				var intersects = raycaster.intersectObject( model, true );

				//console.log(intersects, intersects[0]?.object?.name);

				if( intersects.length && (intersects[0].object.name || intersects[0].object.parent.name) )
				{
					controls.enabled = false;
					
					var name = intersects[0].object.name || intersects[0].object.parent.name;

					//console.log('name',name);
					
					select( model[name] );

					document.getElementById('namex').innerHTML = model[name].nameUI.x||'N/A';
					document.getElementById('namey').innerHTML = model[name].nameUI.y||'N/A';
					document.getElementById('namez').innerHTML = model[name].nameUI.z||'N/A';
			
					dragPoint.position.copy( obj.worldToLocal(intersects[0].point) );
					obj.imageWrapper.add( dragPoint );
					
					obj.imageWrapper.add( circle );
					circle.position.y = (obj instanceof Ankle)?2:0;

					updateValues();
				}
				renderer.setAnimationLoop(drawFrame);
			}

			function relativeTurn( joint, rotationalAngle, angle )
			{
				if( !rotationalAngle )
				{
					// it is translation, not rotation
					joint.position.y += angle;
					return;
				}
				
				if( joint.biologicallyImpossibleLevel )
				{
					if( elemBR.checked )
					{
						// there is a dedicated function to check biological possibility of joint
						var oldImpossibility = joint.biologicallyImpossibleLevel();
						
						joint[rotationalAngle] += angle;
						joint.updateMatrix();
						joint.updateWorldMatrix(true); // ! important, otherwise get's stuck
						
						var newImpossibility = joint.biologicallyImpossibleLevel();

						if( newImpossibility>EPS && newImpossibility>=oldImpossibility-EPS )
						{
							// undo rotation
							joint[rotationalAngle] -= angle;
							return;
						}
					}
					else
					{
						joint.biologicallyImpossibleLevel();
						joint[rotationalAngle] += angle;
					}
					// keep the rotation, it is either possible, or improves impossible situation
				}
				else
				{
					// there is no dedicated function, test with individual rotation range
					
					var val = joint[rotationalAngle]+angle,
						min = joint.minRot[rotationalAngle],
						max = joint.maxRot[rotationalAngle];
						
					if( elemBR.checked || min==max )
					{
						if( val<min-EPS && angle<0 ) return;
						if( val>max+EPS && angle>0 ) return;
						if( min == max ) return;
					}

					joint[rotationalAngle] = val;
				}
				joint.updateMatrix();
			} // relativeTurn
			
			function kinematic2D( joint, rotationalAngle, angle, ignoreIfPositive )
			{
				// returns >0 if this turn gets closer
				
				screenPoint.copy( dragPoint.position );
				screenPoint = obj.localToWorld( screenPoint ).project( camera );
				
				var distOriginal = mouse.distanceTo( screenPoint ),
					oldAngle = joint[rotationalAngle];
				
				relativeTurn( joint, rotationalAngle, angle );
				joint.updateMatrixWorld( true );
				
				screenPoint.copy( dragPoint.position );
				screenPoint = obj.localToWorld( screenPoint ).project( camera );
				
				var distProposed = mouse.distanceTo( screenPoint ),
					dist = distOriginal - distProposed;
				
				if( ignoreIfPositive && dist>0 ) return dist;
				
				joint[rotationalAngle] = oldAngle;
				joint.updateMatrixWorld( true );
				
				return dist;
			}
			
			function inverseKinematics( joint, rotationalAngle, step )
			{
				// try going in postive or negative direction
				var kPos = kinematic2D(joint,rotationalAngle,0.001),
					kNeg = kinematic2D(joint,rotationalAngle,-0.001);

				// if any of them improves closeness, then turn in this direction
				if( kPos>0 || kNeg>0 )
				{
					if( kPos < kNeg ) step = -step;
					kinematic2D(joint,rotationalAngle,step,true);
				}
			}
			
			function animate( time )
			{
				// no selected object
				if( !obj || !mouseButton ) return;

				var elemNone = !elemM1.checked && !elemM2.checked && !elemM3.checked && !elemM4.checked,
					spinA = (obj instanceof Ankle)?Math.PI/2:0;

				circle.rotation.set(0,0,-spinA);
				if( elemM2.checked || elemNone&&mouseButton&2 ) circle.rotation.set(0,Math.PI/2,2*spinA);
				if( elemM3.checked || elemNone&&mouseButton&4 ) circle.rotation.set(Math.PI/2,0,-Math.PI/2);
				
				var joint = obj;
				do
				{
					for( var step = 45; step>0.1; step *= 0.5 )
					{
						if( elemM1.checked || elemNone&&(mouseButton&0x1) )
							inverseKinematics( joint, 'z', step );
						if( elemM2.checked || elemNone&&(mouseButton&0x2) )
							inverseKinematics( joint, 'x', step );
						if( elemM3.checked || elemNone&&(mouseButton&0x4) )
							inverseKinematics( joint, 'y', step );
						if( elemM4.checked )
							inverseKinematics( joint, '', step );
					}
					joint = joint.parentJoint;
				}
				while( !(joint instanceof Mannequin) && !(joint instanceof Pelvis) && !(joint instanceof Torso) && elemIK.checked );
			}
			
			function onMouseMove( event )
			{
				if( obj ) userInput( event );
			}

			function userInput( event )
			{
				if( event instanceof MouseEvent )
				{
					event.preventDefault();
					
					mouseInterface = true;
					mouseButton = event.buttons || 0x1;

					mouse.x = event.clientX/window.innerWidth * 2 - 1;
					mouse.y = -event.clientY/window.innerHeight * 2 + 1;
				}
				
				if( event instanceof TouchEvent && event.touches.length==1)
				{
					mouseButton = 0x1;

					touchInterface = true;
					mouse.x = event.touches[0].clientX/window.innerWidth * 2 - 1;
					mouse.y = -event.touches[0].clientY/window.innerHeight * 2 + 1;
				}
			}
			
		</script>
	</body>	
</html>